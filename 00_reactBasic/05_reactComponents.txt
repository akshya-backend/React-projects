# Let's create a text file that deeply explains FUNCTION-BASED React components only

function_component_explanation = """
===========================================
DEEP EXPLANATION: FUNCTION-BASED REACT COMPONENTS
===========================================

1. WHAT IS A FUNCTION COMPONENT?
--------------------------------
A Function Component is a plain JavaScript function that:
    - Accepts an object called "props" as its argument
    - Returns a React element (via JSX or React.createElement)

They are simpler than class components and are now the preferred way to write components in React.

Example:
    function Greeting(props) {
        return <h1>Hello, {props.name}</h1>;
    }

Arrow function style:
    const Greeting = ({ name }) => <h1>Hello, {name}</h1>;

------------------------------------------------------------
2. PROPS (PROPERTIES)
------------------------------------------------------------
Props are how data is passed from a parent component to a child component.

Example:
    function Welcome({ name }) {
        return <h1>Welcome, {name}!</h1>;
    }

    // Usage:
    <Welcome name="Akshya" />

Here:
    - The parent passes `name="Akshya"`
    - Inside Welcome, we access it as props.name or via destructuring

Props are immutable: a function component cannot change the props it receives.

------------------------------------------------------------
3. STATE WITH HOOKS
------------------------------------------------------------
Function components use the `useState` hook to manage internal state.

Example:
    import React, { useState } from 'react';

    function Counter() {
        const [count, setCount] = useState(0);

        return (
            <div>
                <p>Count: {count}</p>
                <button onClick={() => setCount(count + 1)}>Increase</button>
            </div>
        );
    }

Here:
    - useState(0) returns [count, setCount]
    - count is the current value
    - setCount updates it, causing the component to re-render

------------------------------------------------------------
4. SIDE EFFECTS WITH HOOKS
------------------------------------------------------------
Function components use the `useEffect` hook to handle side effects (like fetching data, subscribing to events, etc.).

Example:
    import React, { useState, useEffect } from 'react';

    function Timer() {
        const [seconds, setSeconds] = useState(0);

        useEffect(() => {
            const interval = setInterval(() => {
                setSeconds(prev => prev + 1);
            }, 1000);

            return () => clearInterval(interval); // Cleanup
        }, []); // Empty dependency array -> runs once

        return <p>Timer: {seconds}</p>;
    }

------------------------------------------------------------
5. RE-RENDERING BEHAVIOR
------------------------------------------------------------
- Function components re-run from the top every time their props or state change
- React optimizes updates by only changing what is necessary in the DOM

------------------------------------------------------------
6. COMPOSING FUNCTION COMPONENTS
------------------------------------------------------------
You can build complex UIs by nesting function components.

Example:
    function Header() {
        return <h1>My App</h1>;
    }

    function App() {
        return (
            <div>
                <Header />
                <p>Welcome to my app!</p>
            </div>
        );
    }

------------------------------------------------------------
7. BEST PRACTICES
------------------------------------------------------------
- Keep components small and focused
- Use props for configuration, state for internal changes
- Avoid unnecessary state; derive it from props when possible
- Use hooks for side effects and state management
- Prefer arrow functions for inline handlers

------------------------------------------------------------
8. FUNCTION COMPONENT LIFECYCLE (WITH HOOKS)
------------------------------------------------------------
Equivalent to class component lifecycle methods:
    - componentDidMount -> useEffect(..., [])
    - componentDidUpdate -> useEffect(..., [dependencies])
    - componentWillUnmount -> return cleanup function from useEffect

------------------------------------------------------------
9. FUNCTION COMPONENT VS REACT ELEMENT
------------------------------------------------------------
| Function Component        | React Element               |
|---------------------------|-----------------------------|
| A function returning JSX  | A plain object describing UI|
| Can use hooks and state   | Immutable                   |
| Called by React to render | Created by React.createElement|

------------------------------------------------------------
10. ADVANTAGES OF FUNCTION COMPONENTS
------------------------------------------------------------
- Simpler syntax and easier to read
- Can use React hooks for state and lifecycle
- Encouraged by modern React
- Easier testing and debugging
"""


